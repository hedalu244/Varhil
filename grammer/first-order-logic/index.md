---
layout: default
title: Varhil/grammer/first-order-logic
---

## 意味

Varhilの解釈は、Varhil文集合から意味集合への全射である。つまり、一つのVarhil文が複数の意味に解釈されることはなく、また、Varhil文で表せない意味は存在しない。ここで意味とは、以下のようにアレンジした一階述語論理の閉論理式である。

+ 述語はアリティ（項の数）の代わりに、格集合という有限集合が決まっている。引数はその順番ではなく、$述語記号(格記号:変数記号, 格記号:変数記号...)$ のように、格との対応を使って区別する（[名前付き引数(named parameter)](https://en.wikipedia.org/wiki/Named_parameter)に似ている）。
+ 定数記号や関数記号は使わない。
+ 論理記号は $\\lnot$、$\\land$、$\\exists$ のみを使う。
+ $\\lor$ がないので、$( P \\lor Q )$ の代わりに $\\lnot ( \\lnot P \\land \\lnot Q )$ を使う。
+ $\\Rightarrow$ がないので、$( P \\Rightarrow Q )$ の代わりに $\\lnot ( P \\land \\lnot Q )$ を使う。  
+ $\\forall$ がないので、$( \\forall x P )$ の代わりに $( \\lnot ( \\exists x \\lnot P ) )$ を使う。  
+ 二重否定は（真偽値は同じだとしても、論理式としては）区別される（ $( ( \\lnot (\\lnot P) )$ と $P$ は別）。
+ 論理積の交換は（真偽値は同じだとしても、論理式としては）区別される（ $( P \\land Q )$ と $( Q \\land P )$ は別）。
+ 論理積の結合は区別されない（ $( P \\land ( Q \\land R ))$ や $(( P \\land Q ) \\land R )$ は $( P \\land Q \\land R )$ と同じ）。
+ 存在量化どうしや存在量化と論理積の順序は区別されない（ $( \\exists x; \\exists y; P)$ と $(\\exists y; \\exists x; P)$ は同じ、また、$( P \\land ( \\exists x; Q ) )$ は $(\\exists x; (P \\land Q) )$ と同じ）。
+ 否定と存在量化の順序は区別される( $(\\exists x; (\\lnot P) )$ と $(\\lnot ( \\exists x; P) )$ は別）。
+ 束縛変数の入れ替えは区別しない。（$\\exists x; (x)$ と $\\exists y; P(y)$ は同じ）

ここでは例として以下のような述語を使う。

{:.words}
リンゴだ(は:x)
: xはリンゴだ

人間だ(は:x)
: xは人間だ

赤い(は:x)
: xは赤い

食べる(が:x, を:y)
: xがyを食べる

## 変数と変項語

**変数** は、述語論理の変数記号に対応する概念で、一つの議論対象を意味する。  

**変項語** は変数を表現するトークンである。
変項語は, `<>`, `<自然数>`, `<自然数+>`, `<自然数->` の4種類がある。文中に出現した変項語と変数の対応は以下のように決定される。  

+ `<>` は出現毎に他のどの変項語の出現とも異なる変数を指す。
+ 自然数が異なる変項語は、異なる変数を指す。
+ `<自然数+>` の形は、それまでに出現したどの変項語とも異なる変数を指す。
+ `<自然数>` の形と `<自然数->` の形は、同じ番号の変項語の一つ前の出現と同じ変数を指す。
+ `<自然数->` の形は、それ以後に出現するどの変項語とも異なる変数を指す。
+ 上記条件が矛盾する場合、エラーである。

ある番号の変項語を語順で見て最後に使用するとき、あるいは、ある番号の変更語をその変数を指して使う最後のときは、必ず、`<～+>`とすることで変数が新たに割り当てられたことを明示する。
各々の変項語を最後に使用するときは `<～->` とすることで、その変数がそれ以後使われないことを明示できる（必須ではない）。

## 述語と前置詞

**述語** は述語論理の述語記号に対応するトークンであり、識別子のみで表される。

**前置詞** は述語に格を指定しながら変数を割り当てるためのトークンであり、//(格) の形で表される。

述語の前に、前置詞と変項語を交互に置くことで **原子文** を作ることができる。原子文は原子論理式を表現する。例えば原子論理式 `食べる(が:x, を:y)` は `//(が) <0+> //(を) <1+> 食べる` のように書くことができる

原子文は統語的には二分木の構造をしている。

原子文は以下の操作が許される。

### 格の入れ替え
格の順序が変わっても意味は変わらない。例えば以下の二文は等価である。

{:.examples}
//(が) <0+> //(を) <1+> 食べる
: //(を) <1+> //(が) <0+> 食べる

### 格の省略
格に変項が渡されなかった場合は、その場限りの変数（つまり `<>`）が渡されたと考える。

{:.examples}  
人間だ
: $\\exists x 人間だ(は:x)$
:（何かは）人間だ

//(を) <0+> 食べる
: $\\exists x \\exists y 食べる(を:x, が:y)$  

## 連言
原子文と後述する複文を合わせて **単文** と呼ぶ。単文を1つ以上並べたものを **連言** と呼び、各単文の論理積を表す。論理積は可換なので、単文の順序を入れ替えても（変項語の `new` や `delete` を調整すれば）同じ意味になる。構文解析には不要だが、読みやすさのため、単文の境界にカンマ、文の末尾にピリオドを置くことができる。

{:.examples}
//(は) <0+> リンゴだ, //(は) <0> 赤い.
: $\\exists x リンゴだ(は:x) \\land 赤い(は:x)$
: あるxはリンゴであり、xは赤い

//(は) <0+> リンゴだ, //(は) <0+> 赤い.
: $(\\exists x リンゴだ(は:x)) \\land (\\exists y 赤い(は:y))$
: あるxはリンゴである。また、あるyは赤い

## 否定と量化
連言を **否定開始語** `{!` と **否定終止語** `}!` で挟むことで その連言が表す命題の否定命題を表す単文になる。これを **否定節** と呼ぶ。否定節は単文の一種なので、他の単文と並べて連言を構成したり、単独従属語の後ろに置いたり、他の否定節に入れ子にしたりできる。  

ある変項がその否定部の中でのみ使われている場合、つまり否定部の外にその変項を指す変項語が書かれたり、否定部の外にある述語に変項が渡されたりしていない場合、その存在量化までが否定される。

{:.examples}
{! //(は) <0+> リンゴだ, //(は) <0> 人間だ }!.
: $\\lnot (\\exists x リンゴだ(は:x) \\land 人間だ(は:x))$
: すべての人間はリンゴではない

量化の位置を変えるために、変項を他の単文の前に置いて連言を作ることができる。これを否定部の外等に置くことで、量化を調整することができる。つまり、単文が最後に来ない限り、単文と変項を好きな順に並べて連言を作ることができる。（連言の最後に変項を置けないのは構文解析を簡略化するための制約である）

{:.examples}
<0+>, {! //(は) <0> リンゴだ }!.
: $\\exists x \\lnot リンゴだ(は:x)$
: リンゴではないものがある。

ここまでの文法を使えば、Varhil文を使ってすべての意味を表すことができる。ここからの文法は糖衣構文である。

## 変項の隠蔽

同じ変項が現れる二つの単文は、一定の条件のもとで、**複文** にまとめることができる。複文は二つの単文を並べた連言と同じ意味で、単文の論理積を表すが、連言より変項語が少なく、短くすることができるため、自然言語に似た構文を作ることができる。複文も単文の一種であり、連言や構成することができる。

連言から複文を作る操作を **連結** と呼ぶ。連結は二つの手順からなる。どの変項を使って連結をするか決めたら、まずどちらかの単文から **名詞句** を作り、次にもう片方の単文にある変項語をその名詞句で置き換え、複文を得る。

冠詞は `/[格]` の形で表されるトークンである。原子文から前置詞と変項を一組抜いて、前置詞と同じ格の冠詞に置き換えると、 **名詞句** を作ることができる。名詞句は他の文の中で変項の代わりに使うことができ、抜かれた変数を表す。

例えば、`/[は] リンゴだ` は `//(は) <0> リンゴだ` の `<0>` を表す名詞句である。これを使った複文 `//(は) /[は] リンゴだ 赤い` は `//(は) <0+> リンゴだ, //(は) <0> 赤い` と同じ意味である。

<!--

### 複文の引数から名詞句を作る
複文の引数を構成する変項を用いて名詞句を作る場合も、述語原子文の場合と同様に処理できる。但し、複文の末尾の述語に直接渡されていない引数（例えば複文内の名詞句に含まれる引数）を使って名詞句を作ることはできない。

-->

## 単独否定語

**単独否定語** `/!` は、直後の句を否定する否定節を作る。つまり、単文の前にあればその単文の終わりまで、前置詞や冠詞の前にあれば、その前置詞が修飾している述語まで、述語の前にあればその述語のみを、否定節に含める。

{:.examples}
/! //(は) /[は] リンゴだ 赤い
: {! //(は) <0+> リンゴだ //(は) <0> 赤い }!
: $\\lnot (\\exists x リンゴだ(は:x) \\land 赤い(は:x))$

//(は) /! /[は] リンゴだ 赤い
: //(は) {! <0+> リンゴだ }! //(は) <0> 赤い
: $\\exists x \\lnot (リンゴだ(は:x)) \\land 赤い(は:x)$

//(は) /[は] リンゴだ /! 赤い
: //(は) <0+> リンゴだ {! //(は) <0> 赤い }!
: $\\exists x リンゴだ(は:x) \\land \\lnot (赤い(は:x))$

また、`{!` ～ `}!` 同様、否定される範囲にのみある変項語は否定の中で存在量化され、外側にある変項語は否定の外で量化される。この際、対応する述語が外部になくても（ただ引数として置かれているだけだとでも）、外側にある場合に含めるる。

{:.examples}
/! //(は) <> リンゴだ
: {! //(は) <> リンゴだ }!
: $\\lnot (\\exists x リンゴだ(は:x))$

{:.examples}
//(は) <> /! リンゴだ
: <0+> {! //(は) <0> リンゴだ }!
: $\\exists x \\lnot (リンゴだ(は:x))$

## 統合語
**統合語** `//&` は直後の二つの単文、または二つの名詞句の論理積を表す。

統合語の後ろに二つの単文句を置くとその論理和を表す単文になる。これによって `{!_` ～ `_}!` を `/!` に置き換えることができる。以下の二文は同じ意味を表す。

{:.examples}
{! //(は) <0+> リンゴだ, //(は) <0> 人間だ }!.
: /! //& //(は) <0+> リンゴだ, //(は) <0> 人間だ }!.

統合語の後ろに二つの名詞句を置くと、二つの名詞句の論理積と、それらの名詞句が表す変数を等号で結んだ名詞句を作る。名詞句はそれらが表す変数を同一視した変数を表す。ところでどちらか片方が名詞句の場合、この構文は自然言語の形容詞のように見える。

{:.examples}
//(が) 人間だ //(を) //& 赤い リンゴだ 食べる.
: $\\exists xy 人間だ(は:x) \\land 赤い(は:y) \\land リンゴだ(は:y) \\land 食べる(が:x, を:y)$
: リンゴがあり、赤いものがあり、人間はそのどちらでもあるものを食べる。
: 人間は赤いリンゴを食べる

//(が) 人間だ //(を) //& <0+> リンゴだ moku //(は) <0> 赤い.
: $\\exists xy 人間だ(は:x) \\land リンゴだ(は:y) \\land 食べる(が:x, を:y) \\land 赤い(は:y)$
: 人間はリンゴを食べる。そのリンゴは赤い。


## 形式的な定義

### 意味集合の定義

<!--

ある集合を$V$とし、$V$の元を **変数記号** と呼ぶ。ある集合を$P$とし、$P$の元を **述語記号** と呼ぶ。$V$や$P$は無限集合でも有限集合でもよい。

$P$を添字集合とする集合族$C$がある。この要素を **格集合** と呼び、格集合の元を **格記号** と呼ぶ。格集合はすべて有限集合である。

述語記号$p$と、$C_p$から変数記号$V$への写像$A$の組$ (p, A )$を **原子論理式** と呼ぶ。

**論理式** を以下のように再帰的に定義する。

+ 任意の原子論理式は論理式である。
+ $e$が論理式ならば、シングルトン$\\{ e \\}$は論理式であり、$ ( \\lnot e )$ を表す。
+ $e_0 , ... , e_n$が論理式なら、順序対$( e_0 , ... , e_n )$は論理式であり、論理積$ ( e_0 \\land e_1 \\land ... \\land e_n )$を表す。但し$e_0 , ... , e_n$のいずれも論理積や量化であってはいけない。
+ $e$が論理式で、 $v_0 ... v_n ∈F ( e )$ならば、順序対$( \\{v_0 , ... , v_n \\} , e )$は論理式であり、存在量化$( \\exists v_0 ... \\exists v_n e )$を表す。但し$e$が存在量化であってはいけない。

より厳密に書くと、

\\begin{align}  
E_0 &= \\{ (p, A ) \\mid p \\in P \\land A \\in ( C_p \\to V ) \\} \\\\  
E^\\prime_0 &= \\varnothing \\\\  
E^{\\prime\\prime}\_0 &= \\varnothing \\\\  
E_{n+1} &= E_n \\cup \\{ \\{ e \\} \\mid e \\in E_n \\cup E^\\prime_n \\cup E^{\\prime\\prime}\_n \\} \\\\  
E^\\prime_{n+1} &= \\{ ( e_0 , ... , e_n ) \\mid e_0 ... e_n \\in E_n \\} \\\\  
E^{\\prime\\prime}\_{n+1} &= \\{ ( \\{v_0 , ... , v_n \\} , e ) \\mid ( e \\in E_n \\cup E^\\prime_n ) \\land v_0 ... v_n \\in F ( e ) \\} \\\\  
\\end{align}

としたときの $ E = \\bigcup \\{ E_n \\cup E^\\prime_n \\cup E^{\\prime\\prime}\_n \\mid n \\in \\mathbb{N} \\}$ が論理式全体の集合である。

各論理式$ e$について **自由変数** の集合$F ( e ) (F ( e ) \\subset V )$を以下のように定義する。

+ 原子論理式$ (p, A ) \\in E$について、、$F ( (p, A ) )$は$A$の値域である。
+ シングルトン$\\{ e \\} \\in E$について、$F ( \\{ e \\} )=f ( e )$である。
+ 順序対$( e_0 , ... , e_n ) \\in E$について、$F ( ( e_0 , ... , e_n ) )=F ( e_0 ) \\cup F ( e_1 ) \\cup ... \\cup F ( e_n )$である。
+ 順序対$( \\{v_0 , ... , v_n \\} , e ) \\in E$について、$F ( ( \\{v_0 , ... , v_n \\} , e ) ) = \\{ v \\in F ( e ) \\mid v \\notin \\{ v_0, ..., v_n \\} \\}$ である。

論理式$ e \\in E$のうち、$F ( e ) = \\varnothing$であるものを、ここでの **意味** とする。

-->

ある集合を$P$とし、$P$の元を **述語記号** と呼ぶ。$P$は無限集合でも有限集合でもよい。

$P$を添字集合とする集合族$C$がある。この要素を **格集合** と呼び、格集合の元を **格記号** と呼ぶ。格集合はすべて有限集合である。

例えば、今まで使ってきたものは

\\begin{align}
P &= \\{ "リンゴだ", "人間だ", "赤い", "食べる" \\} \\\\  
C_{"リンゴだ"} &= \\{ "は" \\} \\\\  
C_{"人間だ"} &= \\{ "は" \\} \\\\  
C_{"赤い"} &= \\{ "は" \\} \\\\  
C_{"食べる"} &= \\{ "が", "を" \\}
\\end{align}

というような形にあらわせる。

変数名の置き換えを区別したくないので、変数は格の素集合分割によって表現する。

**論理式** は式 $e$、変数と対応付けられていない格の集合 $f$、束縛変数の集合 $b$ の三つ組 $(e, f, b)$ であり、以下のように再帰的に定義される。

+ 述語記号$p$と、 $C_p$ と空集合の組 $(p, C_p, \\varnothing)$を **原子論理式** と呼ぶ。任意の原子論理式は論理式である。
+ $\\phi = (e, f, b)$が論理式ならば、$(\\{ (e, f, b) \\}, f, b)$は論理式であり、$ ( \\lnot \\phi )$ を表す。
+ $\\phi_0 , ... , \\phi_n = (e_0, f_0, b_0) , ... , (e_n, f_n, b_n)$が論理式なら、$(((e_0, f_0, b_0) , ... , (e_n, f_n, b_n)), \\bigsqcup_{k=0}^n f_k,
\\bigsqcup_{k=0}^n b_k )$は論理式であり、論理積$ ( \\phi_0 \\land ... \\land \\phi_n )$を表す。但し$\\phi_0 , ... , \\phi_n$のいずれも論理積や量化であってはいけない。
+ $\\phi = (e, f, b)$が論理式で、 $\\{ v_0 , ...  , v_n \\} \\subset \\mathfrak{P} (f)$ かつ $ \\forall a,b \\in {0, ..., n} ; v_a \\cap v_b = \\varnothing $ならば、$(( \\{v_0 , ... , v_n \\} , (e, f, b)), \\{c \\in f \\mid c \\notin \\bigcup \\{ v_0 , ... , v_n \\} \\}, b \\cup \\{ v_0 , ...  , v_n \\})$は論理式であり、存在量化$( \\exists v_0 , ... , v_n ; \\phi )$を表す。但し$\\phi$が存在量化であってはいけない。

より厳密に書くと、

\\begin{align}  
E_0 &= \\{ (p, C_p, \\varnothing) \\mid p \\in P \\} \\\\  
E^\\prime_0 &= \\varnothing \\\\  
E^{\\prime\\prime}\_0 &= \\varnothing \\\\  
E_{n+1} &= E_n \\cup \\{ (\\{ (e, f, b) \\}, f, b) \\mid (e, f, b) \\in ( E_n \\cup E^\\prime_n \\cup E^{\\prime\\prime}\_n ) \\} \\\\  
E^\\prime_{n+1} &= \\{ (((e_0, f_0, b_0) , ... , (e_n, f_n, b_n)), \\bigsqcup_{k=0}^n f_k , \\bigsqcup_{k=0}^n b_k) \\mid \\{ (e_0, f_0, b_0) , ... , (e_n, f_n, b_n) \\} \\subset E_n ,  \\} \\\\  
E^{\\prime\\prime}\_{n+1} &= \\{ (( v , (e, f, b)), \\{c \\in f \\mid c \\notin \\bigcup v \\} , b \\cup v) \\mid (e, f, b) \\in ( E_n \\cup E^\\prime_n ) , v \\subset \\mathfrak{P} (f), \\varnothing \\notin v ,\\forall a,b \\in v ; a \\cap b = \\varnothing \\} \\\\  
\\end{align}

としたときの $ E = \\bigcup \\{ E_n \\cup E^\\prime_n \\cup E^{\\prime\\prime}\_n \\mid n \\in \\mathbb{N} \\}$ が論理式全体の集合である。

論理式$ (e, f, b) \\in E$のうち、$f = \\varnothing$であるものを、**意味** とする。

### トークンの挙動

統語論でも述べた通り、トークンは複数集まって句を形成する。文中の任意の句に対して、その意味を定義できる。

句は論理式といくつかの付加情報が定まる。

句は大まかに **述語句**、**名詞句**、**述語名詞句**、**単文句** の4種類がある。

それぞれの述語句にはそれが表す論理式と、 **主述語** と呼ばれる述語が定義される。主述語は論理式中にある述語（原子論理式）へのポインタである。

それぞれの名詞句には論理式と **主変数** と呼ばれる変数が定義される。

それぞれの述語名詞句には論理式のほか、主述語と主変数がそれぞれ定義される。

単文句は論理式のみが定義される。

変項語はそれ単体で名詞句となる。その論理式は空積（真）であり、その主変数は、その変項語が示す変数である。

述語はそれ単体で述語句となる。その論理式はその述語の全ての格に別々の変数を割り当てた原子論理式であり、主述語はその述語である。

<!--
Sentence -> Conjunctive "."?

Conjunctive -> (SingleSentence ","?)* SingleSentence

SingleSentence -> "/!" SingleSentence
SingleSentence -> Predicate
SingleSentence -> Variable
SingleSentence -> "{!" Conjunctive "}!"

Predicate -> Identifier
Predicate -> "/!" Predicate
Predicate -> Preposition Noun Predicate

Noun -> Variable
Noun -> "/!" Noun
Noun -> "//&" Noun Noun
Noun -> PredicateNoun

PredicateNoun -> "/!" PredicateNoun
PredicateNoun -> Article Predicate
PredicateNoun -> Preposition Noun PredicateNoun
//PredicateNoun -> Predicate

Variable -> "<" Number ">" ("New" | "Delete")?
Variable -> "<>"

Preposition -> "//(" Identifier ")"
Article -> "/[" Identifier "]" ...

Number
Identifier
-->

冠詞は直後の述語句を名詞述語句に変換する。その際、述語句の主述語の、その冠詞の格に割り当てられている変数を主変数に設定する。論理式や主述語は述語句のものを継承する。

前置詞は直後の名詞句または名詞述語句を、その直後の述語句または名詞述語句に作用させる。前置詞は、直後の句の主変数で、その直後の句の主述語の、前置詞が表す格に割り当てられた変数を上書きする。生成される句の論理式は2つの句の論理積であり、句の種類や主述語は2つ目の句のものを継承する。

単独否定語は直後の句の論理式を否定した句を形成する。句の種類、主述語や主変数は直後の句のものを継承する。

統合語は直後の2つの単文句の論理積を表す単文句を形成する。また、二つの句が名詞句だった場合、それらの主変数をマージする。

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$', '$'], ["\\(", "\\)"]],
    displayMath: [['$$', '$$'], ["\\[", "\\]"]],
    processEscapes: true
  }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_SVG" async></script>

## パーサの挙動

### 字句解析

字句解析では、入力文字列をトークンの配列に分解する。  

トークンは、その語形から、品詞や付随する情報が得られる。  

品詞は *single-variable*,　*new-variable*, *continued-variable*, *last-variable*, *predicate*, *article*, *preposition*, *union*, *single-negation*, *open-negation*, *close-negation* の11種ある。  
その他、入力の先頭に *open-sentence*, 末尾に *sentence_close* が挿入される。  

single-variable, union, single-negation, open-negation, close-negation, open-sentence, sentence_close は品詞以外の情報を持たない（即ち1語だけが属する、機能語的な品詞である）。  
new-variable, continued-variable, last-variable は、品詞の他、*character* の情報(文字列)を持つ。  
predicate は品詞の他、*name* の情報(文字列)を持つ。  
article, preposition は品詞の他、*casus* の情報(文字列)を持つ。  

### 構文解析

構文解析では、以下の構造に従って抽象構文木を構築する。  

構文は基本的にポーランド記法である。但し、可変長アリティの関数については括弧のような構造がある。  

single-variable,　new-variable, continued-variable, last-variable, predicate は アリティ 0 の関数（つまり項）である。  
article と single-negation はアリティ 1 の関数である。  
preposition と union は アリティ 2 の関数である。  
open-negation ～ close-negation, open-sentence ～ close-sentence は括弧のように対応し、間の値を引数とる可変アリティの関数である。  

この構造は自明に構文厳密である。

### 意味解析

意味解析では、各トークンに対応する演算を、抽象構文木に従って計算する。  

#### 戻り値の型

各演算の引数と戻り値は、 *変数* の配列と *論理式* 、*主変数* と *主述語* からなるオブジェクトである。  

変数(品詞とは異なる)は、整数をメンバーに持つオブジェクトである。  
*変数* の配列は、その内部で何回変数が登場したかを管理する。  

述語論理式は、述語名と、適用されている引数の配列をメンバーに持つ。ここで引数とは、格と変数からなるオブジェクトである。
等式は 2 つの変数を等号で結んだものである  
論理式 は 等式と述語論理式を ∃、∧、￢ を使って結合したものである。  

主変数は変数（の参照）であり、主述語は論理式の中にある述語原子論理式の参照である。  
主変数と主述語は未定義の場合もある。  

#### 計算の進行

兄弟ノードの中では兄（入力順で先頭に近かった）ノードから順に計算され、子ノードがすべて計算されてから親ノードが計算される。特に、single-variable,　new-variable, continued-variable, last-variable の処理は副作用を持つので、これらが入力順に計算されることが重要である。  

変数は共有のハッシュテーブルに登録され、後から参照することができる。ハッシュテーブルはパースの度に初期化される。  

single-variable は新しい変数を生成する。  
new-variable は新しい変数を生成し、character に紐づけてハッシュテーブルに登録する。既にそのcharacterで登録されていても上書きする。  
continued-variable はハッシュテーブルからその character に紐づけられている変数を取得する。もし登録がなかった場合は警告を出し、新たな変数を生成してハッシュテーブルに登録する。  
last-variable はハッシュテーブルからその character に紐づけられている変数を取得し、その変数をハッシュテーブルから削除する。登録がなかった場合は警告を出し、新たな変数を生成してハッシュテーブルに登録する。  
これらの戻り値はいずれも、論理式は空積（T）、variables は生成または取得した変数一つを持つ配列、主変数はその変数、主述語は未定義である。  

predicate はその述語名と空の引数リストを持つ述語式を生成する。戻り値の論理式と主述語はその述語論理式、variablesは空、主変数は未定義である。  

article は新しい変数を生成し、その格と変数の組を、引数の主述語の引数に加える。戻り値の論理式は加工した引数の論理式、variables は引数の varialbles に生成した変数を加えたものとなる。  
引数に主述語が定義されていない場合、または主変数が定義されている場合はエラーを吐く。  

single-negation は、引数の論理式を量化したうえで否定し、変数は主変数、主述語はそのまま返す。  
open-negation ～ close-negation は引数の論理式の論理積を量化したうえで否定したものを返す。主変数、主述語はundefined。  
open-sentence ～ close-sentence は引数の論理式の論理積を量化したものを返す。主変数、主述語はundefined。  
