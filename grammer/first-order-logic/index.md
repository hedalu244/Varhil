---
layout: default
title: Varhil/grammer/first-order-logic
---

## 意味

Varhilの解釈は、Varhil文集合から意味集合への全射である。つまり、一つのVarhil文が複数の意味に解釈されることはなく、また、Varhil文で表せない意味は存在しない。ここで意味とは、以下のようにアレンジした一階述語論理の閉論理式である。

+ 述語はアリティ（項の数）の代わりに、格集合という有限集合が決まっている。引数はその順番ではなく、$述語記号(格記号:変数記号, 格記号:変数記号...)$ のように、格との対応を使って区別する（[名前付き引数(named parameter)](https://en.wikipedia.org/wiki/Named_parameter)に似ている）。
+ 定数記号や関数記号は使わない。
+ 論理記号は $\\lnot$、$\\land$、$\\exists$ のみを使う。
+ $\\lor$ がないので、$( P \\lor Q )$ の代わりに $\\lnot ( \\lnot P \\land \\lnot Q )$ を使う。
+ $\\Rightarrow$ がないので、$( P \\Rightarrow Q )$ の代わりに $\\lnot ( P \\land \\lnot Q )$ を使う。  
+ $\\forall$ がないので、$( \\forall x P )$ の代わりに $( \\lnot ( \\exists x \\lnot P ) )$ を使う。  
+ 二重否定は（真偽値は同じだとしても、論理式としては）区別される（ $( ( \\lnot (\\lnot P) )$ と $P$ は別）。
+ 論理積の交換は（真偽値は同じだとしても、論理式としては）区別される（ $( P \\land Q )$ と $( Q \\land P )$ は別）。
+ 論理積の結合は区別されない（ $( P \\land ( Q \\land R ))$ や $(( P \\land Q ) \\land R )$ は $( P \\land Q \\land R )$ と同じ）。
+ 存在量化どうしや存在量化と論理積の順序は区別されない（ $( \\exists x; \\exists y; P)$ と $(\\exists y; \\exists x; P)$ は同じ、また、$( P \\land ( \\exists x; Q ) )$ は $(\\exists x; (P \\land Q) )$ と同じ）。
+ 否定と存在量化の順序は区別される( $(\\exists x; (\\lnot P) )$ と $(\\lnot ( \\exists x; P) )$ は別）。
+ 束縛変数の入れ替えは区別しない。（$\\exists x; (x)$ と $\\exists y; P(y)$ は同じ）

ここでは例として以下のような述語を使う。

{:.words}
リンゴだ(は:x)
: xはリンゴだ

人間だ(は:x)
: xは人間だ

赤い(は:x)
: xは赤い

食べる(が:x, を:y)
: xがyを食べる

## 変数と定名詞

**変数** は、述語論理の変数記号に対応する概念で、一つの議論対象を意味する。  

**定名詞** は変数を表現するトークンである。
定名詞は, `<自然数>`, `<自然数+>`, `<自然数->` の3種類がある。文中に出現した定名詞と変数の対応は以下のように決定される。  

+ 自然数が異なる定名詞は、異なる変数を指す。
+ `<自然数+>` の形は、それまでに出現したどの定名詞とも異なる変数を指す。
+ `<自然数>` の形と `<自然数->` の形は、同じ番号の定名詞の一つ前の出現と同じ変数を指す。
+ `<自然数->` の形は、それ以後に出現するどの定名詞とも異なる変数を指す。
+ 上記条件が矛盾する場合、エラーである。

ある番号の定名詞を語順で見て最後に使用するとき、あるいは、ある番号の定名詞をその変数を指して使う最後のときは、必ず、`<～+>`とすることで変数が新たに割り当てられたことを明示する。
各々の定名詞を最後に使用するときは `<～->` とすることで、その変数がそれ以後使われないことを明示できる（必須ではない）。

いかなる状況に於いても、例えば文や段落を跨いだ場合や、発話者が変わった場合でも、それぞれの定名詞が表す変数はリセットされない。これを利用すれば、定名詞を介して以前の段落で使った変数や他の発話者が使った変数を以後の段落で参照することもできる（そうされたくない場合は `-` を付ければよい）し、逆に以前とは異なる変数を指したいときは必ず `+` を付ける必要がある。

不定名詞 `<>` は出現毎に他のどの定名詞の出現とも異なる変数を指す。

定名詞と不定名詞は単独でその変数を表す **名詞句** になれる。

## 述語

**述語** は述語論理の述語記号に対応するトークンであり、識別子のみで表される。

述語は単独でそれ自身を表す **述語句** になれる。

## 前置詞と述語句

**述語句** は、論理式と述語ポインタを情報として持つ統語的まとまりである。述語ポインタは論理式中のある述語記号の位置の情報である（論理式中に同じ述語記号が複数回現れた場合でも、述語ポインタはそれぞれを区別する）。

述語は単独で述語句になることができる。この場合、論理式は引数を持たない状態の述語記号であり、述語ポインタはその述語記号を指す。

**前置詞** は `//(格)` の形で表されるトークンである。

前置詞は直後に名詞句、その後ろに述語句を取り、述語句を成す前置二項演算子であり、述語句の述語ポインタが表す述語記号の、前置詞が表す格に、名詞句が表す変数を割り当てる操作を行う。形成される述語句は、それぞれの論理式の論理積と、述語句の述語ポインタを表す。

<!-- 例えば原子論理式 `食べる(が:x, を:y)` は `//(が) <0+> //(を) <1+> 食べる` のように書くことができる -->

述語句は単独で単文になれる。

## 関係詞と名詞句

**名詞句** は、論理式と変数を情報として持つ統語的まとまりである。

定名詞と不定名詞は単独でその変数を表す名詞句になれる。この場合、論理式として空積（真）を、変数としてその名詞が表す変数を表す。

**関係詞** は `//[格]` の形で表されるトークンである。

関係詞は直後に述語句、その後ろに名詞句を取り、名詞句を成す前置二項演算子であり、述語句の述語ポインタが表す述語記号の、関係詞が表す格に、名詞句が表す変数を割り当てる操作を行う。形成される名詞句は、それぞれの論理式の論理積と、名詞句の変数を表す。

<!-- 例えば、`/[は] リンゴだ` は `//(は) <0> リンゴだ` の `<0>` を表す名詞句である。これを使った複文 `//(は) /[は] リンゴだ <0> 赤い` は `//(は) <0+> リンゴだ, //(は) <0> 赤い` と同じ意味である。 -->

名詞句も述語句と同様、単文になることができる。

### 一般名詞

ある特定の格を **無標格** とする。ここでは格「は」（英語のbe動詞の補語）に対応する格を無標格とする。

無標格を表す関係詞が二番目の引数に不定名詞を取っている場合（ある述語句が無標格関係詞と不定名詞に挟まれている場合）、さらにその名詞句が単文になっていないとき、その関係詞と不定名詞は省略できる。つまり、無標格を取る述語句は単独で名詞句になれる。この名詞句や名詞句に慣れる述語を便宜上 **一般名詞** と呼ぶ。

これを読むときは、名詞句であるべきところ（前置詞の第一引数や関係詞の第二引数）に述語句が置かれていたとき（またその時に限って）、無標格と不定名詞（つまりその場限りの変数）を補えばよい。

## 連言
単文を1つ以上並べたものを **連言** と呼び、各単文の論理積を表す。論理積は可換なので、単文の順序を入れ替えても（定名詞の `new` や `delete` を調整すれば）同じ意味になる。構文解析には不要だが、読みやすさのため、単文の境界にカンマ、文の末尾にピリオドを置くことができる。

## 否定と量化
連言を **否定開始** `{!` と **否定終止** `}!` で挟むことで その連言が表す命題の否定命題を表す単文になる。
これを **否定節** と呼ぶ。否定節も他の単文と並べて連言を構成したり、他の否定節に入れ子にしたりできる。  

文中のすべての変数は存在量化される。但し、ある変数がその否定部の中でのみ使われている場合（否定部の外にその変数を指す定名詞も、その変数が渡される述語もない場合）、その存在量化までが否定される。（￢∃と考えても良いし、∀￢と考えても良い）。

{:.examples}
{! //(は) <0+> リンゴだ, //(は) <0> 人間だ }!.
: $\\lnot (\\exists x リンゴだ(は:x) \\land 人間だ(は:x))$
: すべての人間はリンゴではない

### 単独否定

**単独否定** `/!` は、直後の句を否定する否定節を作る前置単項演算子である。単文の前にあればその単文の終わりまで、前置詞や関係詞の前にあればそれが形成する述語句や名詞句の終わりまで、述語の前にあればその述語のみを否定する。定名詞、不定名詞の前にあった場合はそれのみを否定するが、これは空積の否定なのでナンセンスである。また、単独否定を二つ重ねることもできるが、二重否定なのでナンセンスである（古典論理に従い、二重否定を除去しても意味が変わらない意味論を採用する）

また、`{!` ～ `}!` 同様、否定される範囲でのみ使用される変数は否定の中で存在量化され、外側でも使用される変数は否定の外で量化される。この際、対応する述語が外部になくても（ただ引数として置かれているだけだとでも）、外側にある場合に含めるる。

{:.examples}
/! //(は) /[は] リンゴだ 赤い
: {! //(は) <0+> リンゴだ //(は) <0> 赤い }!
: $\\lnot (\\exists x リンゴだ(は:x) \\land 赤い(は:x))$

//(は) /! /[は] リンゴだ 赤い
: //(は) {! <0+> リンゴだ }! //(は) <0> 赤い
: $\\exists x \\lnot (リンゴだ(は:x)) \\land 赤い(は:x)$

//(は) /[は] リンゴだ /! 赤い
: //(は) <0+> リンゴだ {! //(は) <0> 赤い }!
: $\\exists x リンゴだ(は:x) \\land \\lnot (赤い(は:x))$

{:.examples}
/! //(は) <> リンゴだ
: {! //(は) <> リンゴだ }!
: $\\lnot (\\exists x リンゴだ(は:x))$

{:.examples}
//(は) <> /! リンゴだ
: <0+> {! //(は) <0> リンゴだ }!
: $\\exists x \\lnot (リンゴだ(は:x))$

## 形式的な定義

### 意味集合の定義

<!--

ある集合を$V$とし、$V$の元を **変数記号** と呼ぶ。ある集合を$P$とし、$P$の元を **述語記号** と呼ぶ。$V$や$P$は無限集合でも有限集合でもよい。

$P$を添字集合とする集合族$C$がある。この要素を **格集合** と呼び、格集合の元を **格記号** と呼ぶ。格集合はすべて有限集合である。

述語記号$p$と、$C_p$から変数記号$V$への写像$A$の組$ (p, A )$を **原子論理式** と呼ぶ。

**論理式** を以下のように再帰的に定義する。

+ 任意の原子論理式は論理式である。
+ $e$が論理式ならば、シングルトン$\\{ e \\}$は論理式であり、$ ( \\lnot e )$ を表す。
+ $e_0 , ... , e_n$が論理式なら、順序対$( e_0 , ... , e_n )$は論理式であり、論理積$ ( e_0 \\land e_1 \\land ... \\land e_n )$を表す。但し$e_0 , ... , e_n$のいずれも論理積や量化であってはいけない。
+ $e$が論理式で、 $v_0 ... v_n ∈F ( e )$ならば、順序対$( \\{v_0 , ... , v_n \\} , e )$は論理式であり、存在量化$( \\exists v_0 ... \\exists v_n e )$を表す。但し$e$が存在量化であってはいけない。

より厳密に書くと、

\\begin{align}  
E_0 &= \\{ (p, A ) \\mid p \\in P \\land A \\in ( C_p \\to V ) \\} \\\\  
E^\\prime_0 &= \\varnothing \\\\  
E^{\\prime\\prime}\_0 &= \\varnothing \\\\  
E_{n+1} &= E_n \\cup \\{ \\{ e \\} \\mid e \\in E_n \\cup E^\\prime_n \\cup E^{\\prime\\prime}\_n \\} \\\\  
E^\\prime_{n+1} &= \\{ ( e_0 , ... , e_n ) \\mid e_0 ... e_n \\in E_n \\} \\\\  
E^{\\prime\\prime}\_{n+1} &= \\{ ( \\{v_0 , ... , v_n \\} , e ) \\mid ( e \\in E_n \\cup E^\\prime_n ) \\land v_0 ... v_n \\in F ( e ) \\} \\\\  
\\end{align}

としたときの $ E = \\bigcup \\{ E_n \\cup E^\\prime_n \\cup E^{\\prime\\prime}\_n \\mid n \\in \\mathbb{N} \\}$ が論理式全体の集合である。

各論理式$ e$について **自由変数** の集合$F ( e ) (F ( e ) \\subset V )$を以下のように定義する。

+ 原子論理式$ (p, A ) \\in E$について、、$F ( (p, A ) )$は$A$の値域である。
+ シングルトン$\\{ e \\} \\in E$について、$F ( \\{ e \\} )=f ( e )$である。
+ 順序対$( e_0 , ... , e_n ) \\in E$について、$F ( ( e_0 , ... , e_n ) )=F ( e_0 ) \\cup F ( e_1 ) \\cup ... \\cup F ( e_n )$である。
+ 順序対$( \\{v_0 , ... , v_n \\} , e ) \\in E$について、$F ( ( \\{v_0 , ... , v_n \\} , e ) ) = \\{ v \\in F ( e ) \\mid v \\notin \\{ v_0, ..., v_n \\} \\}$ である。

論理式$ e \\in E$のうち、$F ( e ) = \\varnothing$であるものを、ここでの **意味** とする。

-->

ある集合を$P$とし、$P$の元を **述語記号** と呼ぶ。$P$は無限集合でも有限集合でもよい。

$P$を添字集合とする集合族$C$がある。この要素を **格集合** と呼び、格集合の元を **格記号** と呼ぶ。格集合はすべて有限集合である。

例えば、今まで使ってきたものは

\\begin{align}
P &= \\{ "リンゴだ", "人間だ", "赤い", "食べる" \\} \\\\  
C_{"リンゴだ"} &= \\{ "は" \\} \\\\  
C_{"人間だ"} &= \\{ "は" \\} \\\\  
C_{"赤い"} &= \\{ "は" \\} \\\\  
C_{"食べる"} &= \\{ "が", "を" \\}
\\end{align}

というような形にあらわせる。

変数名の置き換えを区別したくないので、変数は格の素集合分割によって表現する。

**論理式** は式 $e$、変数と対応付けられていない格の集合 $f$、束縛変数の集合 $b$ の三つ組 $(e, f, b)$ であり、以下のように再帰的に定義される。

+ 述語記号$p$と、 $C_p$ と空集合の組 $(p, C_p, \\varnothing)$を **原子論理式** と呼ぶ。任意の原子論理式は論理式である。
+ $\\phi = (e, f, b)$が論理式ならば、$(\\{ (e, f, b) \\}, f, b)$は論理式であり、$ ( \\lnot \\phi )$ を表す。
+ $\\phi_0 , ... , \\phi_n = (e_0, f_0, b_0) , ... , (e_n, f_n, b_n)$が論理式なら、$(((e_0, f_0, b_0) , ... , (e_n, f_n, b_n)), \\bigsqcup_{k=0}^n f_k,
\\bigsqcup_{k=0}^n b_k )$は論理式であり、論理積$ ( \\phi_0 \\land ... \\land \\phi_n )$を表す。但し$\\phi_0 , ... , \\phi_n$のいずれも論理積や量化であってはいけない。
+ $\\phi = (e, f, b)$が論理式で、 $\\{ v_0 , ...  , v_n \\} \\subset \\mathfrak{P} (f)$ かつ $ \\forall a,b \\in {0, ..., n} ; v_a \\cap v_b = \\varnothing $ならば、$(( \\{v_0 , ... , v_n \\} , (e, f, b)), \\{c \\in f \\mid c \\notin \\bigcup \\{ v_0 , ... , v_n \\} \\}, b \\cup \\{ v_0 , ...  , v_n \\})$は論理式であり、存在量化$( \\exists v_0 , ... , v_n ; \\phi )$を表す。但し$\\phi$が存在量化であってはいけない。

より厳密に書くと、

\\begin{align}  
E_0 &= \\{ (p, C_p, \\varnothing) \\mid p \\in P \\} \\\\  
E^\\prime_0 &= \\varnothing \\\\  
E^{\\prime\\prime}\_0 &= \\varnothing \\\\  
E_{n+1} &= E_n \\cup \\{ (\\{ (e, f, b) \\}, f, b) \\mid (e, f, b) \\in ( E_n \\cup E^\\prime_n \\cup E^{\\prime\\prime}\_n ) \\} \\\\  
E^\\prime_{n+1} &= \\{ (((e_0, f_0, b_0) , ... , (e_n, f_n, b_n)), \\bigsqcup_{k=0}^n f_k , \\bigsqcup_{k=0}^n b_k) \\mid \\{ (e_0, f_0, b_0) , ... , (e_n, f_n, b_n) \\} \\subset E_n ,  \\} \\\\  
E^{\\prime\\prime}\_{n+1} &= \\{ (( v , (e, f, b)), \\{c \\in f \\mid c \\notin \\bigcup v \\} , b \\cup v) \\mid (e, f, b) \\in ( E_n \\cup E^\\prime_n ) , v \\subset \\mathfrak{P} (f), \\varnothing \\notin v ,\\forall a,b \\in v ; a \\cap b = \\varnothing \\} \\\\  
\\end{align}

としたときの $ E = \\bigcup \\{ E_n \\cup E^\\prime_n \\cup E^{\\prime\\prime}\_n \\mid n \\in \\mathbb{N} \\}$ が論理式全体の集合である。

論理式$ (e, f, b) \\in E$のうち、$f = \\varnothing$であるものを、**意味** とする。

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$', '$'], ["\\(", "\\)"]],
    displayMath: [['$$', '$$'], ["\\[", "\\]"]],
    processEscapes: true
  }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_SVG" async></script>

## パーサの挙動

### 字句解析

字句解析では、入力文字列をトークンの配列に分解する。  

トークンは、その語形から、品詞や付随する情報が得られる。  

品詞は *single-variable*,　*new-variable*, *continued-variable*, *last-variable*, *predicate*, *relative*, *preposition*, *single-negation*, *open-negation*, *close-negation* の11種ある。  
その他、入力の先頭に *open-sentence*, 末尾に *sentence_close* が挿入される。  

single-variable, single-negation, open-negation, close-negation, open-sentence, sentence_close は品詞以外の情報を持たない（即ち1語だけが属する、機能語的な品詞である）。  
new-variable, continued-variable, last-variable は、品詞の他、*character* の情報(文字列)を持つ。  
predicate は品詞の他、*name* の情報(文字列)を持つ。  
relative, preposition は品詞の他、*casus* の情報(文字列)を持つ。  

### 構文解析

構文解析では、以下の構造に従って抽象構文木を構築する。  

構文は基本的にポーランド記法である。但し、可変長アリティの関数については括弧のような構造がある。  

single-variable,　new-variable, continued-variable, last-variable, predicate は アリティ 0 の関数（つまり項）である。  
single-negation はアリティ 1 の関数である。  
preposition と relative は アリティ 2 の関数である。  
open-negation ～ close-negation, open-sentence ～ close-sentence は括弧のように対応し、間の値を引数とる可変アリティの関数である。  

この構造は自明に構文厳密である。

### 意味解析

意味解析では、各トークンに対応する演算を、抽象構文木に従って計算する。  

#### 戻り値の型

各演算の引数と戻り値は、 *変数* の配列と *論理式* 、*主変数* と *主述語* からなるオブジェクトである。  

変数(品詞とは異なる)は、整数をメンバーに持つオブジェクトである。  
*変数* の配列は、その内部で何回変数が登場したかを管理する。  

述語論理式は、述語名と、適用されている引数の配列をメンバーに持つ。ここで引数とは、格と変数からなるオブジェクトである。
等式は 2 つの変数を等号で結んだものである  
論理式 は 等式と述語論理式を ∃、∧、￢ を使って結合したものである。  

主変数は変数（の参照）であり、主述語は論理式の中にある述語原子論理式の参照である。  
主変数と主述語は未定義の場合もある。  

#### 計算の進行

兄弟ノードの中では兄（入力順で先頭に近かった）ノードから順に計算され、子ノードがすべて計算されてから親ノードが計算される。特に、single-variable,　new-variable, continued-variable, last-variable の処理は副作用を持つので、これらが入力順に計算されることが重要である。  

変数は共有のハッシュテーブルに登録され、後から参照することができる。ハッシュテーブルはパースの度に初期化される。  

single-variable は新しい変数を生成する。  
new-variable は新しい変数を生成し、character に紐づけてハッシュテーブルに登録する。既にそのcharacterで登録されていても上書きする。  
continued-variable はハッシュテーブルからその character に紐づけられている変数を取得する。もし登録がなかった場合は警告を出し、新たな変数を生成してハッシュテーブルに登録する。  
last-variable はハッシュテーブルからその character に紐づけられている変数を取得し、その変数をハッシュテーブルから削除する。登録がなかった場合は警告を出し、新たな変数を生成してハッシュテーブルに登録する。  
これらの戻り値はいずれも、論理式は空積（T）、variables は生成または取得した変数一つを持つ配列、主変数はその変数、主述語は未定義である。  

predicate はその述語名と空の引数リストを持つ述語式を生成する。戻り値の論理式と主述語はその述語論理式、variablesは空、主変数は未定義である。  

relative は第二引数の、その格と変数の組を、引数の主述語の引数に加える。戻り値の論理式は加工した述語句の論理式と名詞句の論理式の論理積、variables は引数の varialbles に生成した変数を加えたもの、主変数は第二引数の主変数である。  
引数に主述語が定義されていない場合、または主変数が定義されている場合はエラーを吐く。  

single-negation は、引数の論理式を量化したうえで否定し、変数は主変数、主述語はそのまま返す。  
open-negation ～ close-negation は引数の論理式の論理積を量化したうえで否定したものを返す。主変数、主述語はundefined。  
open-sentence ～ close-sentence は引数の論理式の論理積を量化したものを返す。主変数、主述語はundefined。  
